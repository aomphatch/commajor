<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="utf-8" />
  <title>Vertex Shader • pos.z = sin(pos.x*PI + uTime) (three.js r128)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0
    }

    canvas {
      display: block
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
  <script>
    // Scene / Camera / Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0.6, 2.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    new THREE.OrbitControls(camera, renderer.domElement);

    // Axes
    const axes = new THREE.AxesHelper(2.0);
    scene.add(axes);

    // Lights
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 10, 0);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambient);

    // ==================== Shaders ====================
    const vert = `
      uniform float uTime;
      varying vec3 vNormal;
      varying vec3 vPosW;
      varying vec2 vUv;

      void main(){
        vNormal = normalize(mat3(modelMatrix) * normal);
        vec3 pos = position;
        vUv = uv;
        vPosW = (modelMatrix * vec4(pos, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const frag = `
      precision mediump float;
      varying vec3 vNormal;
      uniform vec3 uLightDir;
      varying vec3 vPosW;
      varying vec2 vUv;
      uniform sampler2D uTex;

      void main() {
        float diffuse = clamp(dot(vNormal, uLightDir), 0.3, 1.0);
        float levels = 4.0;
        diffuse = floor(diffuse * levels) / levels;
        diffuse += 0.5;

        vec3 R = reflect(-uLightDir, vNormal);
        vec3 V = normalize(cameraPosition - vPosW);
        float specular = max(pow(dot(R,V), 8.0), 0.0);
        specular = smoothstep(0.4, 0.6, specular);
        specular = clamp(specular, 0.0, 0.5);
        if(diffuse <= 0.5) specular = 0.0;

        vec3 base = texture2D(uTex, vUv).rgb;
        vec3 color = (base * diffuse) + vec3(specular);

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // ==================== Uniforms ====================
    const uniformsTorus = {
      uTime: { value: 0.0 },
      uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
      uTex: { value: new THREE.TextureLoader().load('https://as1.ftcdn.net/jpg/01/25/53/90/1000_F_125539026_9a4SZL7lOEXB4pem3ERJgrlAWh4Pdfod.jpg') }
    };

    const uniformsModel = {
      uTime: { value: 0.0 },
      uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
      uTex: { value: new THREE.TextureLoader().load('https://aomphatch.github.io/comgraph1509/whalebody_diffuse.png') }
    };

    // ==================== Torus ====================
    const geo = new THREE.TorusBufferGeometry(0.7, 0.2, 32, 64);
    const mat = new THREE.ShaderMaterial({
      vertexShader: vert,
      fragmentShader: frag,
      uniforms: uniformsTorus,
      side: THREE.DoubleSide
    });
    scene.add(new THREE.Mesh(geo, mat));

    // ==================== GLB Model ====================
    const gltfLoader = new THREE.GLTFLoader();
    const url = 'https://aomphatch.github.io/comgraph1509/whale.glb';

    gltfLoader.load(
      url,
      (gltf) => {
        const model = gltf.scene;
        model.scale.set(0.019, 0.019, 0.019);
        model.position.set(-1.1, 0.9 , 1.0);

        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // ถ้า geometry ไม่มี uv แต่มี uv2 → copy มาให้
            if (!child.geometry.attributes.uv && child.geometry.attributes.uv2) {
              child.geometry.setAttribute("uv", child.geometry.attributes.uv2);
            }

            // ✅ สร้าง uniforms แยกสำหรับแต่ละ mesh
            const uniformsModel = {
              uTime: { value: 0.0 },
              uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
              uTex: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/uv_grid_opengl.jpg') }
            };

            // ถ้า material เดิมมี texture → ใช้แทน uniform uTex
            if (child.material.map) {
              uniformsModel.uTex.value = child.material.map;
            }

            // ใช้ ShaderMaterial ของคุณเอง
            child.material = new THREE.ShaderMaterial({
              vertexShader: vert,
              fragmentShader: frag,
              uniforms: uniformsModel,
              side: THREE.DoubleSide,
            });
          }
        });


        scene.add(model);
        console.log("GLB loaded successfully");
      },
      undefined,
      (error) => {
        console.error("Error loading GLB:", error);
      }
    ); 

    // ==================== Ground ====================
    const geoGround = new THREE.PlaneBufferGeometry(10.0, 2.0, 100, 20);
    const matGround = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true });
    const mshGround = new THREE.Mesh(geoGround, matGround);
    mshGround.rotation.x = Math.PI * -0.5;
    scene.add(mshGround);

    // ==================== Red Sphere (marker) ====================
    const sphere = new THREE.SphereBufferGeometry(0.05, 20, 20);
    const matSphere = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const mshSphere = new THREE.Mesh(sphere, matSphere);
    mshSphere.position.set(0, 0, 0);
    scene.add(mshSphere);

    // ==================== Resize & Animate ====================
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    (function loop() {
      const t = performance.now() / 1000;

      uniformsTorus.uTime.value = t;
      uniformsTorus.uLightDir.value.set(0.4, 1.0, 0.8).normalize();

      uniformsModel.uTime.value = t;
      uniformsModel.uLightDir.value.set(0.4, 1.0, 0.8).normalize();

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
