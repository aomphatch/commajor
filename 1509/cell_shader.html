<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="utf-8" />
  <title>Vertex Shader • pos.z = sin(pos.x*PI + uTime) (three.js r128)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0
    }

    canvas {
      display: block
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
  <script>
    // Scene / Camera / Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0.6, 2.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    new THREE.OrbitControls(camera, renderer.domElement);
    //ใส่แกน
    const axes = new THREE.AxesHelper(2.0);
    scene.add(axes);
    
    const uniforms = {
      uTime: { value: 0.0 },
      uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
      uTex: { value: new THREE.TextureLoader().load('https://dm0qx8t0i9gc9.cloudfront.net/thumbnails/image/rDtN98Qoishumwih/cherry_fyYiQRLu_thumb.jpg')  }
    };

    const vert = `
    uniform float uTime;
    varying vec3 vNormal;
    varying vec3 vPosW;
    varying vec2 vUv;   //ตำแหน่งuv เพราะจะแปะtexture

    void main(){
      vNormal = normalize(mat3(modelMatrix) * normal);
      vec3 pos = position;

      //pos.y = pos.y + sin(pos.z *3.0 *3.14 + uTime * 4.0) * 0.1 ;   //ทำให้ขยับ

      vUv = uv;
      vPosW   = ( modelMatrix * vec4(pos, 1.0)).xyz;

      
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `;

    const frag = `
    precision mediump float;
    varying vec3 vNormal;
    uniform vec3 uLightDir;
    varying vec3 vPosW;
    varying vec2 vUv;
    uniform sampler2D uTex;

    void main()
    {

      float diffuse = clamp(dot(vNormal, uLightDir), 0.0, 1.0);
      float levels = 3.0;             //ถ้ากำหนดเป็น3 จะได้เป็น3สี           
      diffuse   = floor(diffuse * levels) / levels;
      diffuse += 0.5;


      vec3 R = reflect(-uLightDir, vNormal);
      vec3 V = normalize(cameraPosition - vPosW);
      float specular = max( pow( dot(R,V), 8.0 ) , 0.0);

      //specular = step(0.5, specular);       //0.9; เกินเป็น1 ต่ำกว่าเป็น0
      specular = smoothstep(0.4, 0.6, specular); //จะไล่เฉดในช่วงที่ตัดให้ คือช่วง 0.4-0.6จะไล่สี
      specular = clamp(specular, 0.0, 0.5);
      if(diffuse <= 0.5) 
        specular = 0.0;

      vec3 base    = texture2D(uTex, vUv).rgb;       
      vec3 color = (base  * diffuse) + vec3(specular);

      gl_FragColor = vec4(color, 1.0);
    }
  `;

    const geo = new THREE.TorusBufferGeometry(0.7, 0.2, 32, 64);
    //const geo = new THREE.SphereBufferGeometry(1, 200, 200);
    //const geo = new THREE.PlaneBufferGeometry(2.0, 2.0, 20, 20);
    const mat = new THREE.ShaderMaterial({
      vertexShader: vert,
      fragmentShader: frag,
      uniforms,
      //wireframe: true
    });

    scene.add(new THREE.Mesh(geo, mat));


    const geoGround = new THREE.PlaneBufferGeometry(10.0, 2.0, 100, 20);
    const matGround = new THREE.MeshBasicMaterial({
      color: 0x444444,
      wireframe: true
    });
    const mshGround = new THREE.Mesh(geoGround, matGround);
    mshGround.rotation.x = Math.PI * -0.5;
    scene.add(mshGround);

    const sphere = new THREE.SphereBufferGeometry(0.05, 20, 20);
    const matSphere = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const mshSphere = new THREE.Mesh(sphere, matSphere);
    mshSphere.position.set(0, 0, 0);
    scene.add(mshSphere);

    // Resize & Animate
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    (function loop() {
      uniforms.uTime.value = performance.now() / 1000; // ปรับความเร็วได้ด้วยการคูณ factor
      uniforms.uLightDir.value.set(
      Math.sin(uniforms.uTime.value)*2.0,
      1.0,
      0.8
    ).normalize();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>