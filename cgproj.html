<!DOCTYPE html>
<html>

<head>
    <title>Load GLB</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <script>
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        // à¹‚à¸«à¸¥à¸” EXR environment
        const exrLoader = new THREE.EXRLoader();
        exrLoader.load('https://aomphatch.github.io/comgraphproj/dikhololo_night_1k.exr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
        });

        // à¸à¸¥à¹‰à¸­à¸‡
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.2, 1000);
        camera.position.set(0, 2, 5);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // à¹à¸ªà¸‡
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffdd00, 0.8, 8);  //(à¸ªà¸µ, à¸„à¸§à¸²à¸¡à¹€à¸‚à¹‰à¸¡à¹à¸ªà¸‡, distance â€“ à¸£à¸°à¸¢à¸°à¸—à¸µà¹ˆà¹à¸ªà¸‡à¸ˆà¸°à¸¡à¸µà¸œà¸¥)
        pointLight.position.set(-3.2,1.5,-1.5);
        pointLight.castShadow = true;
        scene.add(pointLight);
        const pointLightHelper = new THREE.PointLightHelper(pointLight, 1);   //à¸•à¸±à¸§à¸Šà¹ˆà¸§à¸¢à¸—à¸µà¹ˆà¸—à¸³à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¸‚à¸­à¸‡à¸«à¸¥à¸­à¸”à¹„à¸Ÿ
        scene.add(pointLightHelper);

        /*const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 7, -3);
        directionalLight.castShadow = true;*/
        /*
        directionalLight.shadow.mapSize.set(1024, 1024);
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -5;
        directionalLight.shadow.camera.right = 5;
        directionalLight.shadow.camera.top = 5;
        directionalLight.shadow.camera.bottom = -5;
        
        scene.add(directionalLight);
        scene.add(new THREE.DirectionalLightHelper(directionalLight, 1)); */

        // GUI
        /*
        const gui = new dat.GUI();
        const lightSettings = {
            lightX: directionalLight.position.x,
            lightY: directionalLight.position.y,
            lightZ: directionalLight.position.z,
            lightIntensity: directionalLight.intensity,
            exposure: renderer.toneMappingExposure
        };
        const lightFolder = gui.addFolder('Directional Light');
        lightFolder.add(lightSettings, 'lightX', -10, 10).onChange(v => directionalLight.position.x = v);
        lightFolder.add(lightSettings, 'lightY', 0, 15).onChange(v => directionalLight.position.y = v);
        lightFolder.add(lightSettings, 'lightZ', -10, 10).onChange(v => directionalLight.position.z = v);
        lightFolder.add(lightSettings, 'lightIntensity', 0, 5).onChange(v => directionalLight.intensity = v);
        lightFolder.open();
        gui.add(lightSettings, 'exposure', 0, 5).onChange(v => renderer.toneMappingExposure = v);
        */

        const gltfLoader = new THREE.GLTFLoader();
        const arcade = 'https://aomphatch.github.io/comgraphproj/arcade.glb';
        const shop = 'https://aomphatch.github.io/comgraphproj/shop.glb';
        const tomb = 'https://aomphatch.github.io/comgraphproj/tomb.glb';
        const light = 'https://aomphatch.github.io/comgraphproj/light.glb';
        const convex = 'https://aomphatch.github.io/comgraphproj/convex.glb';
        const busstop = 'https://aomphatch.github.io/comgraphproj/busstop.glb';
        const vespa = 'https://aomphatch.github.io/comgraphproj/vespa.glb';

        /*Arcade Loader*/
        gltfLoader.load(
           arcade,
            (gltf) => {
                const arcadeModel = gltf.scene;
                //const pbrFolder = gui.addFolder("PBR"); // folder à¹€à¸”à¸µà¸¢à¸§à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸¸à¸ material
                //pbrFolder.open(); // à¹€à¸›à¸´à¸” folder à¸—à¸±à¸™à¸—à¸µ
                    // Reset à¸„à¹ˆà¸²à¹ƒà¸«à¹‰à¹à¸™à¹ˆà¹ƒà¸ˆà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡ origin à¹à¸¥à¸°à¸‚à¸™à¸²à¸”à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸”
                /*arcadeModel.position.set(0, 0, 0);
                arcadeModel.scale.set(1, 1, 1);
                arcadeModel.rotation.set(0, 0, 0);*/

                arcadeModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸Šà¸·à¹ˆà¸­ à¸•à¸±à¹‰à¸‡à¹€à¸›à¹‡à¸™ Mesh + id

                        // à¸ªà¸£à¹‰à¸²à¸‡ slider à¸ªà¸³à¸«à¸£à¸±à¸š roughness à¹à¸¥à¸° metalness à¸ à¸²à¸¢à¹ƒà¸™ folder "PBR"
                        /*
                        pbrFolder.add(mat, "roughness", 0, 1, 0.01).name(meshName + " Roughness");
                        pbrFolder.add(mat, "metalness", 0, 1, 0.01).name(meshName + " Metalness");
                        */
                        }
                });

                scene.add(arcadeModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Shop Loader*/
        gltfLoader.load(
           shop,
            (gltf) => {
                const shopModel = gltf.scene;

                shopModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸Šà¸·à¹ˆà¸­ à¸•à¸±à¹‰à¸‡à¹€à¸›à¹‡à¸™ Mesh + id
                        }
                });

                scene.add(shopModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Tomb Loader*/
        gltfLoader.load(
           tomb,
            (gltf) => {
                const tombModel = gltf.scene;

                tombModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // ðŸ”§ à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² roughness / metalness à¸•à¸£à¸‡à¸™à¸µà¹‰
                        child.material.roughness = 1.0;   // à¸„à¹ˆà¸²à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ 0 = à¸¡à¸±à¸™à¸§à¸²à¸§ à¸¡à¸²à¸ â†’ 1 = à¸”à¹‰à¸²à¸™
                        //child.material.metalness = 0.2;   // à¸„à¹ˆà¸²à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ 0 = à¹„à¸¡à¹ˆà¹€à¸›à¹‡à¸™à¹‚à¸¥à¸«à¸° â†’ 1 = à¹‚à¸¥à¸«à¸°
                    }
                });

                scene.add(tombModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Light Loader*/
        gltfLoader.load(
           light,
            (gltf) => {
                const lightModel = gltf.scene;

                lightModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸Šà¸·à¹ˆà¸­ à¸•à¸±à¹‰à¸‡à¹€à¸›à¹‡à¸™ Mesh + id
                        }
                });

                scene.add(lightModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Convex Loader*/
        gltfLoader.load(
           convex,
            (gltf) => {
                const convexModel = gltf.scene;

                convexModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸Šà¸·à¹ˆà¸­ à¸•à¸±à¹‰à¸‡à¹€à¸›à¹‡à¸™ Mesh + id
                        }
                });

                scene.add(convexModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Busstop Loader*/
        gltfLoader.load(
           busstop,
            (gltf) => {
                const busstopModel = gltf.scene;

                busstopModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        const mat = child.material;
                        const meshName = child.name || `Mesh ${child.id}`; // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸Šà¸·à¹ˆà¸­ à¸•à¸±à¹‰à¸‡à¹€à¸›à¹‡à¸™ Mesh + id
                        }
                });

                scene.add(busstopModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        /*Vespa Loader*/
        gltfLoader.load(
           vespa,
            (gltf) => {
                const vespaModel = gltf.scene;

                vespaModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // ðŸ”§ à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² roughness / metalness à¸•à¸£à¸‡à¸™à¸µà¹‰
                        child.material.roughness = 0.8;   // à¸„à¹ˆà¸²à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ 0 = à¸¡à¸±à¸™à¸§à¸²à¸§ à¸¡à¸²à¸ â†’ 1 = à¸”à¹‰à¸²à¸™
                        child.material.metalness = 0.2;   // à¸„à¹ˆà¸²à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ 0 = à¹„à¸¡à¹ˆà¹€à¸›à¹‡à¸™à¹‚à¸¥à¸«à¸° â†’ 1 = à¹‚à¸¥à¸«à¸°
                    }
                });     

                scene.add(vespaModel);
                console.log("GLB loaded successfully");
            },
            undefined,
            (error) => {
                console.error("Error loading GLB:", error);
            }
        );

        // à¸žà¸·à¹‰à¸™
        const floorTex = new THREE.TextureLoader().load('https://aomphatch.github.io/comgraphproj/rocky_terrain_02_diff_1k.jpg', t => {
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
        });
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshStandardMaterial({ map: floorTex })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
        
    </script>
</body>

</html>
