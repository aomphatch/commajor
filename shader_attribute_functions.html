<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Vertex Shader • pos.z = sin(pos.x*PI + uTime) (three.js r128)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>html,body{height:100%;margin:0} canvas{display:block}</style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<script>
  // Scene / Camera / Renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 0.6, 2.2);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  new THREE.OrbitControls(camera, renderer.domElement);
  
  
  const axesHelper = new THREE.AxesHelper(5); //กำหนดขนาดของแกน 
  scene.add(axesHelper);

  
  const uniforms = { 
    uTime: { value: 0.0 } ,
    uLightDir: {value: new THREE.Vector3(0.4, 1.0, 0.8).normalize()}
  };

  const vert = `
    uniform float uTime;
    varying vec3 vNormal;

    void main(){
      float PI = 3.141592653589793;
      vNormal = normalize(normalMatrix * normal);

      vec3 pos = position;

      pos.y = pos.y + sin(pos.x * PI  + uTime) * 0.2 ;
      pos.z = pos.z + sin(pos.x * PI  + uTime) * 0.3 ;

      //ลองใช้วิธีปรับตำแหน่งแกน y
      //pos.y = sin(pos.x);
      
      //ลองใช้วิธีปรับตำแหน่งแกน z 
      //pos.z = sin(pos.x);
      

      //ทดลองใช้วิธีปรับตำแหน่งจาก Normal 
      vec3 N = normalize(normal); 
      pos = pos + (N * sin(pos.x + uTime)*0.1) ; // ปรับความสูงได้ด้วยการคูณ factor

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `;

  const frag = `
    precision mediump float;
    varying vec3 vNormal;
    uniform vec3  uLightDir;

    void main()
    { 
      float g = dot(vNormal, uLightDir) + 0.3;
      gl_FragColor = vec4(1.0, 1.0, 0.2, 1.0) * g; 
    }
  `;

  //const geo = new THREE.PlaneBufferGeometry(2.0, 2.0, 20, 20);
  //const geo = new THREE.SphereBufferGeometry( 1.0, 20, 20);
  const geo = new THREE.TorusBufferGeometry( 0.7, 0.2, 16, 32);
  const mat = new THREE.ShaderMaterial({
    vertexShader: vert,
    fragmentShader: frag,
    uniforms,
    side: THREE.DoubleSide,
    //wireframe: true
  });

  scene.add(new THREE.Mesh(geo, mat));

    const geoGround = new THREE.PlaneBufferGeometry(10.0, 2.0, 100, 20);
    const matGround = new THREE.MeshBasicMaterial({
      color: 0x444444,
      side: THREE.DoubleSide,
      wireframe: true
    });
    const mshGround = new THREE.Mesh(geoGround, matGround);
    mshGround.rotation.x = Math.PI * -0.5;
    scene.add(mshGround);



  // Resize & Animate
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  (function loop(){
    uniforms.uTime.value = performance.now() / 1000; // ปรับความเร็วได้ด้วยการคูณ factor
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  })();
</script>
</body>
</html>
